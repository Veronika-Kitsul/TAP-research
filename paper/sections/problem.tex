\section{Problem statement}
\label{sec:problem}

In a trigger-action system, there is a client, $T$ trigger services, $A$ action
services, and a trigger-action platform (TAP). Each trigger service $i \in [T]$
exposes a set of predicates $\mathbf{P}_i$ that activate the trigger service. A
predicate $p : \mathcal{X} \times \mathcal{C} \to \{0,1\}$ takes as input
trigger data $x \in \mathcal{X}$ and user constant $c \in \mathcal{C}$, and
outputs a bit. Each action service $i \in [A]$ exposes a set of transformations
$\mathbf{T}_i$ that activate the action service. Each transformation $f :
\mathcal{X} \times \mathcal{C} \to \mathcal{Y}$ also takes as input trigger data
$x \in \mathcal{X}$ and user constant $c \in \mathcal{C}$, and outputs an action
$y \in \mathcal{Y}$.

The client sets up a recipe by selecting:
\begin{itemize}
  \item a trigger service $t \in [T]$, a predicate $p \in \mathbf{P}_t$, and a
    trigger constant $c_t \in \mathcal{C}$;
  \item an action service $a \in [A]$, a transformation $f \in \mathbf{T}_a$,
    and an action trigger $c_a \in \mathcal{C}$.
\end{itemize}
When the trigger service $t$ receives trigger data $x_t \in \mathcal{X}$, the
recipe executes as follows:
\[
  \text{if}~p(x_t, c_t)\text{, then send}~f(x_t, c_a)~\text{to}~a.
\]

In today's TAPs, such as IFTTT, trigger data is sent to the TAP and rules are
executed entirely on the TAP. In \textsf{eTAP}~\cite{DBLP:conf/sp/ChenCWSCF21},
rules are executed using MPC, so the TAP learns neither the trigger data nor the
user-supplied constants. We explore another point in this design space that we
argue achieves privacy at much lower cost and complexity.

Our two key observations are the following:
\begin{itemize}
  \item A fixed set of predicates are offered by each trigger service.
  \item User-supplied trigger constants are often not sensitive data to the
    trigger services.
\end{itemize}
Given these observations, in our design, we push the computation of the
predicate $p(x_t, c_t)$ to the trigger service---$p$ is not arbitrary
client-supplied code and $x_t$ and $c_t$ need not be hidden from the trigger
service. \kl{The computation of $p$ is also probably cheaper than encoding
  inputs for MPC. Also computing $p$ in MPC can be quite expensive (e.g., due to
  substring operations).}

The computation of the transformation $f(x_t, c_a)$, however, mixes data from
the trigger service ($x_t$) and data intended for the action service ($c_a$), so
this is executed using MPC on the TAP. To summarize the privacy properties we
are after:
\begin{itemize}
  \item The TAP shouldn't learn $x_t, c_t, c_a$ or the results of $f(x_t, c_a)$.
  \item The action service shouldn't learn $x_t$, except what can be inferred
    from the output of $f(x_t, c_a)$.
\end{itemize}
